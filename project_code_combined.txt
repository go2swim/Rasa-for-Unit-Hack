# Файл: .gitignore
# Содержимое:
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc


================================================================================

# Файл: api_document.txt
# Содержимое:
Документация API: Сервис Распознавания Намерений и Сущностей (NLU)
Обзор

Данный API-сервис предназначен для анализа текста на естественном языке (русском) с целью определения намерения (intent) пользователя и извлечения из текста ключевых сущностей (entities). Это позволяет преобразовывать свободные текстовые запросы в структурированные данные, которые могут быть использованы для дальнейшей обработки, например, для формирования запросов к базе данных или выполнения определенных действий.

Сервис построен на базе Rasa NLU.

Базовый URL

Для локальной разработки (когда Rasa сервер запущен на вашей машине):
http://localhost:5005

При развертывании на сервере, замените localhost:5005 на актуальный адрес и порт вашего Rasa сервера.

Эндпоинт
Анализ текста (NLU Parse)

URL: /model/parse

Метод: POST

Описание: Принимает текстовую строку и возвращает JSON-объект с результатами NLU-анализа, включая наиболее вероятное намерение и список извлеченных сущностей.

Headers:

Content-Type: application/json

Тело запроса (Request Body):
JSON-объект с одним обязательным ключом text.

{
  "text": "Текстовый запрос пользователя"
}


text (string, required): Текстовая строка, которую необходимо проанализировать.

Ответ (Response):

При успехе (Код 200 OK):
JSON-объект следующей структуры:

{
  "text": "Оригинальный текст запроса пользователя",
  "intent": {
    "name": "имя_наиболее_вероятного_интента",
    "confidence": 0.9985123872756958
  },
  "entities": [
    {
      "entity": "тип_сущности_1",
      "start": 6,  // начальный индекс сущности в "text"
      "end": 20,   // конечный индекс сущности в "text"
      "confidence_entity": 0.9701234567890123,
      "value": "извлеченное_значение_сущности_1",
      "extractor": "DIETClassifier"
    },
    {
      "entity": "тип_сущности_2",
      "start": 30,
      "end": 40,
      "confidence_entity": 0.9212345678901234,
      "value": "извлеченное_значение_сущности_2",
      "extractor": "DIETClassifier"
    }
    // ... другие извлеченные сущности
  ],
  "intent_ranking": [
    {
      "name": "имя_наиболее_вероятного_интента",
      "confidence": 0.9985123872756958
    },
    {
      "name": "имя_второго_по_вероятности_интента",
      "confidence": 0.0012345678901234567
    }
    // ... остальные интенты с их уверенностью
  ]
  // ... могут присутствовать другие поля, специфичные для Rasa,
  // но для базового использования достаточно указанных выше.
}

Описание полей ответа:

text (string): Оригинальный текст, отправленный в запросе.

intent (object): Объект, описывающий наиболее вероятное намерение.

name (string): Имя распознанного намерения (например, search_person, greet).

confidence (float): Уровень уверенности модели в этом намерении (от 0.0 до 1.0).

entities (array of objects): Массив объектов, где каждый объект представляет извлеченную сущность. Если сущности не найдены, массив будет пустым.

entity (string): Тип сущности (например, name, department, date).

start (integer): Начальный индекс (с 0) первого символа значения сущности в исходной строке text.

end (integer): Конечный индекс (не включая) последнего символа значения сущности в исходной строке text.

confidence_entity (float): Уровень уверенности модели в извлечении этой сущности.

value (string): Извлеченное текстовое значение сущности.

extractor (string): Имя компонента Rasa, который извлек эту сущность (например, DIETClassifier, RegexFeaturizer).

intent_ranking (array of objects): Массив всех возможных намерений, отсортированных по убыванию уверенности. Полезно для отладки или реализации более сложной логики.

При ошибке: Стандартные HTTP-коды ошибок (например, 4xx, 5xx) с JSON-телом, описывающим ошибку (зависит от конфигурации Rasa).

Текущие поддерживаемые Интенты и Сущности

На данный момент модель обучена распознавать следующие основные интенты и сущности (согласно domain.yml):

Интенты (Намерения):

greet: Приветствие.

goodbye: Прощание.

affirm: Утвердительный ответ.

deny: Отрицательный ответ.

bot_challenge: Проверка, является ли собеседник ботом.

search_person: Запрос на поиск сотрудника.

search_event: Запрос на поиск мероприятия.

find_birthday: Запрос на поиск дней рождения.

check_task: Запрос на проверку задач.

check_employment_calendar: Запрос на проверку календаря занятости.

Сущности (Entities):

name: Имя, фамилия или ФИО человека.

department: Название отдела.

project: Название проекта.

event_name: Название мероприятия.

date: Дата или период времени (например, "завтра", "в июне", "25 мая").

task_name: Название задачи.

(room_name): Упоминается в примерах NLU для check_employment_calendar, но не добавлена в секцию entities в domain.yml. Если планируется использовать, нужно добавить.

Примеры Запросов и Ответов
Пример 1: Поиск сотрудника

Запрос:

curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{
    "text": "Найди Иванова Петра из отдела разработки"
  }'

Ожидаемый ответ (структура):

{
  "text": "Найди Иванова Петра из отдела разработки",
  "intent": {
    "name": "search_person",
    "confidence": 0.99...
  },
  "entities": [
    {
      "entity": "name",
      "start": 6,
      "end": 19,
      "confidence_entity": 0.98...,
      "value": "Иванова Петра",
      "extractor": "DIETClassifier"
    },
    {
      "entity": "department",
      "start": 29,
      "end": 39,
      "confidence_entity": 0.95...,
      "value": "разработки",
      "extractor": "DIETClassifier"
    }
  ],
  "intent_ranking": [
    { "name": "search_person", "confidence": 0.99... },
    // ...
  ]
}

Пример 2: Поиск мероприятия

Запрос:

curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{
    "text": "Какие корпоративы будут на следующей неделе?"
  }'


Ожидаемый ответ (структура):

{
  "text": "Какие корпоративы будут на следующей неделе?",
  "intent": {
    "name": "search_event",
    "confidence": 0.97...
  },
  "entities": [
    {
      "entity": "event_name",
      "start": 6,
      "end": 17,
      "confidence_entity": 0.91...,
      "value": "корпоративы",
      "extractor": "DIETClassifier"
    },
    {
      "entity": "date",
      "start": 27,
      "end": 44,
      "confidence_entity": 0.89...,
      "value": "на следующей неделе", // Точное извлечение даты зависит от компонентов, например, Duckling
      "extractor": "DIETClassifier"  // или другой подходящий экстрактор
    }
  ],
  "intent_ranking": [
    { "name": "search_event", "confidence": 0.97... },
    // ...
  ]
}


Пример 3: Простой запрос без сущностей

Запрос:

curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{
    "text": "Привет"
  }'


Ожидаемый ответ (структура):

{
  "text": "Привет",
  "intent": {
    "name": "greet",
    "confidence": 0.99...
  },
  "entities": [], // Сущности не найдены
  "intent_ranking": [
    { "name": "greet", "confidence": 0.99... },
    // ...
  ]
}

Пример 4: Запрос с синонимом

Запрос:

curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{
    "text": "Где Женя из маркетинга?"
  }'

Ожидаемый ответ (структура):

{
  "text": "Где Женя из маркетинга?",
  "intent": {
    "name": "search_person",
    "confidence": 0.98...
  },
  "entities": [
    {
      "entity": "name",
      "start": 4,
      "end": 8,
      "confidence_entity": 0.96...,
      "value": "Евгений", // EntitySynonymMapper заменил "Женя" на "Евгений"
      "extractor": "DIETClassifier"
    },
    {
      "entity": "department",
      "start": 12,
      "end": 22,
      "confidence_entity": 0.93...,
      "value": "маркетинга",
      "extractor": "DIETClassifier"
    }
  ],
  "intent_ranking": [
    { "name": "search_person", "confidence": 0.98... },
    // ...
  ]
}

================================================================================

# Файл: api_document.txt~
# Содержимое:
Документация API: Сервис Распознавания Намерений и Сущностей (NLU)
Обзор

Данный API-сервис предназначен для анализа текста на естественном языке (русском) с целью определения намерения (intent) пользователя и извлечения из текста ключевых сущностей (entities). Это позволяет преобразовывать свободные текстовые запросы в структурированные данные, которые могут быть использованы для дальнейшей обработки, например, для формирования запросов к базе данных или выполнения определенных действий.

Сервис построен на базе Rasa NLU.

Базовый URL

Для локальной разработки (когда Rasa сервер запущен на вашей машине):
http://localhost:5005

При развертывании на сервере, замените localhost:5005 на актуальный адрес и порт вашего Rasa сервера.

Эндпоинт
Анализ текста (NLU Parse)

URL: /model/parse

Метод: POST

Описание: Принимает текстовую строку и возвращает JSON-объект с результатами NLU-анализа, включая наиболее вероятное намерение и список извлеченных сущностей.

Headers:

Content-Type: application/json

Тело запроса (Request Body):
JSON-объект с одним обязательным ключом text.

{
  "text": "Текстовый запрос пользователя"
}


text (string, required): Текстовая строка, которую необходимо проанализировать.

Ответ (Response):

При успехе (Код 200 OK):
JSON-объект следующей структуры:

{
  "text": "Оригинальный текст запроса пользователя",
  "intent": {
    "name": "имя_наиболее_вероятного_интента",
    "confidence": 0.9985123872756958
  },
  "entities": [
    {
      "entity": "тип_сущности_1",
      "start": 6,  // начальный индекс сущности в "text"
      "end": 20,   // конечный индекс сущности в "text"
      "confidence_entity": 0.9701234567890123,
      "value": "извлеченное_значение_сущности_1",
      "extractor": "DIETClassifier"
    },
    {
      "entity": "тип_сущности_2",
      "start": 30,
      "end": 40,
      "confidence_entity": 0.9212345678901234,
      "value": "извлеченное_значение_сущности_2",
      "extractor": "DIETClassifier"
    }
    // ... другие извлеченные сущности
  ],
  "intent_ranking": [
    {
      "name": "имя_наиболее_вероятного_интента",
      "confidence": 0.9985123872756958
    },
    {
      "name": "имя_второго_по_вероятности_интента",
      "confidence": 0.0012345678901234567
    }
    // ... остальные интенты с их уверенностью
  ]
  // ... могут присутствовать другие поля, специфичные для Rasa,
  // но для базового использования достаточно указанных выше.
}

Описание полей ответа:

text (string): Оригинальный текст, отправленный в запросе.

intent (object): Объект, описывающий наиболее вероятное намерение.

name (string): Имя распознанного намерения (например, search_person, greet).

confidence (float): Уровень уверенности модели в этом намерении (от 0.0 до 1.0).

entities (array of objects): Массив объектов, где каждый объект представляет извлеченную сущность. Если сущности не найдены, массив будет пустым.

entity (string): Тип сущности (например, name, department, date).

start (integer): Начальный индекс (с 0) первого символа значения сущности в исходной строке text.

end (integer): Конечный индекс (не включая) последнего символа значения сущности в исходной строке text.

confidence_entity (float): Уровень уверенности модели в извлечении этой сущности.

value (string): Извлеченное текстовое значение сущности.

extractor (string): Имя компонента Rasa, который извлек эту сущность (например, DIETClassifier, RegexFeaturizer).

intent_ranking (array of objects): Массив всех возможных намерений, отсортированных по убыванию уверенности. Полезно для отладки или реализации более сложной логики.

При ошибке: Стандартные HTTP-коды ошибок (например, 4xx, 5xx) с JSON-телом, описывающим ошибку (зависит от конфигурации Rasa).

Текущие поддерживаемые Интенты и Сущности

На данный момент модель обучена распознавать следующие основные интенты и сущности (согласно domain.yml):

Интенты (Намерения):

greet: Приветствие.

goodbye: Прощание.

affirm: Утвердительный ответ.

deny: Отрицательный ответ.

bot_challenge: Проверка, является ли собеседник ботом.

search_person: Запрос на поиск сотрудника.

search_event: Запрос на поиск мероприятия.

find_birthday: Запрос на поиск дней рождения.

check_task: Запрос на проверку задач.

check_employment_calendar: Запрос на проверку календаря занятости.

Сущности (Entities):

name: Имя, фамилия или ФИО человека.

department: Название отдела.

project: Название проекта.

event_name: Название мероприятия.

date: Дата или период времени (например, "завтра", "в июне", "25 мая").

task_name: Название задачи.

(room_name): Упоминается в примерах NLU для check_employment_calendar, но не добавлена в секцию entities в domain.yml. Если планируется использовать, нужно добавить.

Примеры Запросов и Ответов
Пример 1: Поиск сотрудника

Запрос:

curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{
    "text": "Найди Иванова Петра из отдела разработки"
  }'

Ожидаемый ответ (структура):

{
  "text": "Найди Иванова Петра из отдела разработки",
  "intent": {
    "name": "search_person",
    "confidence": 0.99...
  },
  "entities": [
    {
      "entity": "name",
      "start": 6,
      "end": 19,
      "confidence_entity": 0.98...,
      "value": "Иванова Петра",
      "extractor": "DIETClassifier"
    },
    {
      "entity": "department",
      "start": 29,
      "end": 39,
      "confidence_entity": 0.95...,
      "value": "разработки",
      "extractor": "DIETClassifier"
    }
  ],
  "intent_ranking": [
    { "name": "search_person", "confidence": 0.99... },
    // ...
  ]
}

Пример 2: Поиск мероприятия

Запрос:

curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{
    "text": "Какие корпоративы будут на следующей неделе?"
  }'


Ожидаемый ответ (структура):

{
  "text": "Какие корпоративы будут на следующей неделе?",
  "intent": {
    "name": "search_event",
    "confidence": 0.97...
  },
  "entities": [
    {
      "entity": "event_name",
      "start": 6,
      "end": 17,
      "confidence_entity": 0.91...,
      "value": "корпоративы",
      "extractor": "DIETClassifier"
    },
    {
      "entity": "date",
      "start": 27,
      "end": 44,
      "confidence_entity": 0.89...,
      "value": "на следующей неделе", // Точное извлечение даты зависит от компонентов, например, Duckling
      "extractor": "DIETClassifier"  // или другой подходящий экстрактор
    }
  ],
  "intent_ranking": [
    { "name": "search_event", "confidence": 0.97... },
    // ...
  ]
}


Пример 3: Простой запрос без сущностей

Запрос:

curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{
    "text": "Привет"
  }'


Ожидаемый ответ (структура):

{
  "text": "Привет",
  "intent": {
    "name": "greet",
    "confidence": 0.99...
  },
  "entities": [], // Сущности не найдены
  "intent_ranking": [
    { "name": "greet", "confidence": 0.99... },
    // ...
  ]
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Json
IGNORE_WHEN_COPYING_END
Пример 4: Запрос с синонимом

Запрос:

curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{
    "text": "Где Женя из маркетинга?"
  }'
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Ожидаемый ответ (структура):

{
  "text": "Где Женя из маркетинга?",
  "intent": {
    "name": "search_person",
    "confidence": 0.98...
  },
  "entities": [
    {
      "entity": "name",
      "start": 4,
      "end": 8,
      "confidence_entity": 0.96...,
      "value": "Евгений", // EntitySynonymMapper заменил "Женя" на "Евгений"
      "extractor": "DIETClassifier"
    },
    {
      "entity": "department",
      "start": 12,
      "end": 22,
      "confidence_entity": 0.93...,
      "value": "маркетинга",
      "extractor": "DIETClassifier"
    }
  ],
  "intent_ranking": [
    { "name": "search_person", "confidence": 0.98... },
    // ...
  ]
}

================================================================================

# Файл: config.yml
# Содержимое:
# The config recipe.
# https://rasa.com/docs/rasa/model-configuration/
recipe: default.v1

# The assistant project unique identifier
# This default value must be replaced with a unique assistant name within your deployment
assistant_id: 20250517-014538-moderato-primer # Рекомендуется сменить на уникальное имя вашего проекта

# Configuration for Rasa NLU.
# https://rasa.com/docs/rasa/nlu/components/
language: ru # <<< ИЗМЕНЕНО НА ru

pipeline:
   - name: WhitespaceTokenizer
   - name: RegexFeaturizer
   - name: LexicalSyntacticFeaturizer
   - name: CountVectorsFeaturizer
   - name: CountVectorsFeaturizer
     analyzer: char_wb
     min_ngram: 1
     max_ngram: 4
   - name: DIETClassifier
     epochs: 100 # Для реального проекта может потребоваться больше эпох и данных
     constrain_similarities: true
   - name: EntitySynonymMapper
   # ResponseSelector и FallbackClassifier не обязательны, если вы используете Rasa только для NLU
   # Но они не мешают, если вы вдруг решите добавить диалоговые функции.
   - name: ResponseSelector
     epochs: 100
     constrain_similarities: true
   - name: FallbackClassifier
     threshold: 0.5 # Можно настроить порог
     ambiguity_threshold: 0.1

# Configuration for Rasa Core.
# https://rasa.com/docs/rasa/core/policies/
# Если вы используете Rasa только для NLU, политики Core менее важны,
# но RulePolicy полезна для прямого вызова action после интента.
policies:
   - name: MemoizationPolicy
   - name: RulePolicy
     # Включите это, если хотите, чтобы RulePolicy обрабатывала события от кастомных actions
     # enable_fallback_prediction: True
   - name: UnexpecTEDIntentPolicy
     max_history: 5
     epochs: 100
   - name: TEDPolicy
     max_history: 5
     epochs: 100
     constrain_similarities: true

================================================================================

# Файл: credentials.yml
# Содержимое:
# This file contains the credentials for the voice & chat platforms
# which your bot is using.
# https://rasa.com/docs/rasa/messaging-and-voice-channels

rest:
#  # you don't need to provide anything here - this channel doesn't
#  # require any credentials


#facebook:
#  verify: "<verify>"
#  secret: "<your secret>"
#  page-access-token: "<your page access token>"

#slack:
#  slack_token: "<your slack token>"
#  slack_channel: "<the slack channel>"
#  slack_signing_secret: "<your slack signing secret>"

#socketio:
#  user_message_evt: <event name for user message>
#  bot_message_evt: <event name for bot messages>
#  session_persistence: <true/false>

#mattermost:
#  url: "https://<mattermost instance>/api/v4"
#  token: "<bot token>"
#  webhook_url: "<callback URL>"

# This entry is needed if you are using Rasa Enterprise. The entry represents credentials
# for the Rasa Enterprise "channel", i.e. Talk to your bot and Share with guest testers.
rasa:
  url: "http://localhost:5002/api"


================================================================================

# Файл: domain.yml
# Содержимое:
version: "3.1"

intents:
  - greet
  - goodbye
  - affirm
  - deny
  - bot_challenge
  - search_person:
      use_entities:
        - name
        - department
        - project
  - search_event:
      use_entities:
        - event_name
        - date
  - find_birthday:
      use_entities:
        - name
        - date
  - check_task:
      use_entities:
        - task_name
        - project
        - date
  - check_employment_calendar:
      use_entities:
        - name
        - date

entities:
  - name
  - department
  - project
  - event_name
  - date
  - task_name

slots:
  name:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: name
  department:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: department
  project:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: project
  # ... (остальные слоты как в предыдущем ответе) ...
  event_name:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: event_name
  date:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: date
  task_name:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: task_name

responses:
  utter_greet:
    - text: "Привет! Чем могу помочь?"
  utter_goodbye:
    - text: "До свидания!"
  utter_iamabot:
    - text: "Я AI-ассистент."
  utter_ask_details_person:
    - text: "Можете уточнить имя, фамилию, отдел или проект сотрудника?"
    - text: "Кого именно вы ищете? Пожалуйста, назовите имя, фамилию или другие известные детали."
  # ... (остальные ответы как в предыдущем ответе) ...
  utter_ask_details_event:
    - text: "Какое мероприятие или дата вас интересует?"
  utter_ask_details_task:
    - text: "Уточните название задачи, проекта или дату."
  utter_processing_request:
    - text: "Понял, обрабатываю ваш запрос..."


actions:
  - action_process_request

session_config:
  session_expiration_time: 60
  carry_over_slots_to_new_session: true

================================================================================

# Файл: domain.yml~
# Содержимое:
version: "3.1"

intents:
  - greet
  - goodbye
  - affirm
  - deny
  - bot_challenge
  - search_person:
      use_entities:
        - name
        - department
        - project
  - search_event:
      use_entities:
        - event_name
        - date
  - find_birthday:
      use_entities:
        - name
        - date
  - check_task:
      use_entities:
        - task_name
        - project
        - date
  - check_calendar_занятости:
      use_entities:
        - name
        - date

entities:
  - name
  - department
  - project
  - event_name
  - date
  - task_name

slots:
  name:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: name
  department:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: department
  project:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: project
  # ... (остальные слоты как в предыдущем ответе) ...
  event_name:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: event_name
  date:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: date
  task_name:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: task_name

responses:
  utter_greet:
    - text: "Привет! Чем могу помочь?"
  utter_goodbye:
    - text: "До свидания!"
  utter_iamabot:
    - text: "Я AI-ассистент."
  utter_ask_details_person:
    - text: "Можете уточнить имя, фамилию, отдел или проект сотрудника?"
    - text: "Кого именно вы ищете? Пожалуйста, назовите имя, фамилию или другие известные детали."
  # ... (остальные ответы как в предыдущем ответе) ...
  utter_ask_details_event:
    - text: "Какое мероприятие или дата вас интересует?"
  utter_ask_details_task:
    - text: "Уточните название задачи, проекта или дату."
  utter_processing_request:
    - text: "Понял, обрабатываю ваш запрос..."


actions:
  - action_process_request

session_config:
  session_expiration_time: 60
  carry_over_slots_to_new_session: true

================================================================================

# Файл: endpoints.yml
# Содержимое:
# This file contains the different endpoints your bot can use.

# Server where the models are pulled from.
# https://rasa.com/docs/rasa/model-storage#fetching-models-from-a-server

#models:
#  url: http://my-server.com/models/default_core@latest
#  wait_time_between_pulls:  10   # [optional](default: 100)

# Server which runs your custom actions.
# https://rasa.com/docs/rasa/custom-actions

action_endpoint:
 url: "http://localhost:5055/webhook"

# Tracker store which is used to store the conversations.
# By default the conversations are stored in memory.
# https://rasa.com/docs/rasa/tracker-stores

#tracker_store:
#    type: redis
#    url: <host of the redis instance, e.g. localhost>
#    port: <port of your redis instance, usually 6379>
#    db: <number of your database within redis, e.g. 0>
#    password: <password used for authentication>
#    use_ssl: <whether or not the communication is encrypted, default false>

#tracker_store:
#    type: mongod
#    url: <url to your mongo instance, e.g. mongodb://localhost:27017>
#    db: <name of the db within your mongo instance, e.g. rasa>
#    username: <username used for authentication>
#    password: <password used for authentication>

# Event broker which all conversation events should be streamed to.
# https://rasa.com/docs/rasa/event-brokers

#event_broker:
#  url: localhost
#  username: username
#  password: password
#  queue: queue

================================================================================

# Файл: endpoints.yml~
# Содержимое:
# This file contains the different endpoints your bot can use.

# Server where the models are pulled from.
# https://rasa.com/docs/rasa/model-storage#fetching-models-from-a-server

#models:
#  url: http://my-server.com/models/default_core@latest
#  wait_time_between_pulls:  10   # [optional](default: 100)

# Server which runs your custom actions.
# https://rasa.com/docs/rasa/custom-actions

action_endpoint:
  urls:
    - "http://localhost:5055/webhook"
    - "http://localhost:5005/model/parse"

# Tracker store which is used to store the conversations.
# By default the conversations are stored in memory.
# https://rasa.com/docs/rasa/tracker-stores

#tracker_store:
#    type: redis
#    url: <host of the redis instance, e.g. localhost>
#    port: <port of your redis instance, usually 6379>
#    db: <number of your database within redis, e.g. 0>
#    password: <password used for authentication>
#    use_ssl: <whether or not the communication is encrypted, default false>

#tracker_store:
#    type: mongod
#    url: <url to your mongo instance, e.g. mongodb://localhost:27017>
#    db: <name of the db within your mongo instance, e.g. rasa>
#    username: <username used for authentication>
#    password: <password used for authentication>

# Event broker which all conversation events should be streamed to.
# https://rasa.com/docs/rasa/event-brokers

#event_broker:
#  url: localhost
#  username: username
#  password: password
#  queue: queue

================================================================================

# Файл: README.md
# Содержимое:
# Rasa-for-Unit-Hack

python 3.9

````
pip install rasa[spacy]
pip install rasa-sdk
pip install spacy
python -m spacy download ru_core_news_sm
pip install rasa[transformers] transformers
````

Запуск api (для бека):
````
rasa train (один раз после обновления репоза)
rasa run --enable-api --cors "*" -p 5005
````

Запуск:
````
rasa train
rasa run actions
rasa shell
````


================================================================================

# Файл: README.md~
# Содержимое:
# Rasa-for-Unit-Hack

python 3.9

````
pip install rasa[spacy]
pip install rasa-sdk
pip install spacy
python -m spacy download ru_core_news_sm
pip install rasa[transformers] transformers
````

Запуск:
````
rasa train
rasa run actions
rasa shell
````


================================================================================

# Файл: test_api.py
# Содержимое:
import requests
import json

rasa_url = "http://localhost:5005/model/parse"


def get_nlu_data(text_query):
    payload = {"text": text_query}
    try:
        response = requests.post(rasa_url, json=payload)
        response.raise_for_status()  # Проверка на HTTP ошибки
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Ошибка при обращении к Rasa NLU API: {e}")
        return None


if __name__ == "__main__":
    queries = [
        "Найди Анну Смирнову из IT",
        "Какие мероприятия завтра?",
        "У кого день рождения в июне?",
        "Привет",
        "Покажи мне Волкова Михаила",
        "телефон Кузнецова",
        "Сотрудник Лебедева Наталья из бухгалтерии в проекте Гамма"
    ]

    for query in queries:
        print(f"\nЗапрос: {query}")
        nlu_result = get_nlu_data(query)
        if nlu_result:
            print("Результат NLU:")
            print(f"  Текст: {nlu_result.get('text')}")
            intent = nlu_result.get('intent', {})
            print(f"  Интент: {intent.get('name')} (Confidence: {intent.get('confidence'):.4f})")

            entities = nlu_result.get('entities', [])
            if entities:
                print("  Сущности:")
                for entity in entities:
                    print(f"    - Тип: {entity.get('entity')}, Значение: '{entity.get('value')}', "
                          f"Confidence: {entity.get('confidence_entity', 'N/A'):.4f}")
            else:
                print("  Сущности: не найдены")
            # print(json.dumps(nlu_result, indent=2, ensure_ascii=False)) # Раскомментируйте для полного вывода JSON
        print("-" * 30)

================================================================================

# Файл: actions/actions.py
# Содержимое:
from typing import Any, Text, Dict, List
import logging

from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher

# from rasa_sdk.events import SlotSet, UserUtteranceReverted # Не используются в текущей версии

logger = logging.getLogger(__name__)


class ActionProcessRequest(Action):
    def name(self) -> Text:
        return "action_process_request"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        intent_name = tracker.latest_message['intent'].get('name')
        entities = tracker.latest_message.get('entities', [])  # Убедимся, что entities всегда список

        # Формируем структурированные данные для возможной отправки вовне
        extracted_data = {
            "intent": intent_name,
            "entities": [],
            "text": tracker.latest_message.get('text')
        }

        # Сообщение для логирования и ответа пользователю (для демонстрации)
        log_message_parts = [f"Получен запрос с интентом: {intent_name}"]

        if not entities:
            log_message_parts.append("- Сущности не найдены.")
        else:
            log_message_parts.append("Извлеченные сущности:")
            for entity in entities:
                entity_info = {"entity": entity['entity'], "value": entity['value']}
                if 'group' in entity:  # для regex entities
                    entity_info['group'] = entity['group']
                if 'role' in entity:  # для roles
                    entity_info['role'] = entity['role']

                extracted_data["entities"].append(entity_info)
                log_message_parts.append(
                    f"- {entity['entity']}: {entity['value']} (confidence: {entity.get('confidence_entity', 'N/A'):.2f})")

        final_log_message = "\n".join(log_message_parts)
        logger.info(f"Processing request: {tracker.latest_message.get('text')}\n{final_log_message}")
        logger.info(f"Data to send to backend: {extracted_data}")

        # Ответ пользователю (для демонстрации)
        # dispatcher.utter_message(text=f"Обрабатываю ваш запрос: {tracker.latest_message.get('text')}")
        # dispatcher.utter_message(text=final_log_message) # Можно закомментировать, если не нужен такой подробный ответ в чате

        # Пример специфичной логики для search_person
        if intent_name == "search_person":
            # Собираем все значения для сущности 'name'
            names_found = [e['value'] for e in extracted_data["entities"] if e['entity'] == 'name']
            departments_found = [e['value'] for e in extracted_data["entities"] if e['entity'] == 'department']
            projects_found = [e['value'] for e in extracted_data["entities"] if e['entity'] == 'project']

            # Для простоты берем первое найденное имя, отдел, проект
            name_query = names_found[0] if names_found else "не указано"
            department_query = departments_found[0] if departments_found else "не указан"
            project_query = projects_found[0] if projects_found else "не указан"

            # Это сообщение можно использовать для отладки или как часть ответа
            # dispatcher.utter_message(
            #     text=f"Ищу сотрудника: Имя/Фамилия: '{name_query}', Отдел: '{department_query}', Проект: '{project_query}'."
            # )

            # Здесь ваша логика обращения к БД или API для поиска сотрудника
            # response_from_db = self.query_employee_db(name_query, department_query, project_query)
            # dispatcher.utter_message(text=response_from_db)
            # Для хакатона: просто подтверждаем получение данных
            dispatcher.utter_message(
                text=f"✅ Запрос на поиск сотрудника '{name_query}' (отдел: '{department_query}', проект: '{project_query}') принят.")


        elif intent_name == "search_event":
            event_names_found = [e['value'] for e in extracted_data["entities"] if e['entity'] == 'event_name']
            dates_found = [e['value'] for e in extracted_data["entities"] if e['entity'] == 'date']
            event_query = event_names_found[0] if event_names_found else "не указано"
            date_query = dates_found[0] if dates_found else "не указана"
            dispatcher.utter_message(
                text=f"✅ Запрос на поиск мероприятия '{event_query}' (дата: '{date_query}') принят.")

        # Добавьте обработку других интентов по аналогии
        else:
            # Общий ответ, если для интента нет специфичной логики выше
            dispatcher.utter_message(text=f"✅ Ваш запрос (интент: {intent_name}) принят к обработке.")

        # В реальном приложении здесь бы мог быть вызов вашего API:
        # requests.post("URL_ВАШЕГО_БЭКЕНДА", json=extracted_data)

        return []

    # def query_employee_db(self, name, department, project):
    #     # Заглушка для метода обращения к БД
    #     # В реальном приложении здесь будет код для запроса к вашей базе данных
    #     # Например, используя psycopg2, SQLAlchemy, requests к вашему API и т.д.
    #     logger.info(f"DB Query (simulated): Searching for Name='{name}', Department='{department}', Project='{project}'")
    #     # Пример ответа
    #     if name != "не указано":
    #         return f"Информация по сотруднику '{name}' найдена (симуляция)."
    #     return "Недостаточно данных для поиска сотрудника (симуляция)."

================================================================================

# Файл: actions/__init__.py
# Содержимое:


================================================================================

# Файл: data/nlu.yml
# Содержимое:
version: "3.1"

nlu:
  - intent: greet
    examples: |
      - привет
      - здравствуй
      - добрый день
      - хай
      - здорово

  - intent: goodbye
    examples: |
      - пока
      - до свидания
      - всего доброго
      - бай

  # ... (affirm, deny, bot_challenge как в предыдущем ответе) ...
  - intent: affirm
    examples: |
      - да
      - конечно
      - ага
      - угу
      - согласен

  - intent: deny
    examples: |
      - нет
      - неа
      - не думаю
      - вряд ли

  - intent: bot_challenge
    examples: |
      - ты бот?
      - ты человек?
      - с кем я говорю?

  - intent: search_person
    examples: |
      # Только имя
      - Найди [Анну](name)
      - Где работает [Петр](name)?
      - Мне нужен [Сергей](name) из [IT](department)
      - Кто такая [Ольга](name) из [маркетинга](department)
      - Покажи [Виктора](name)
      - Ищу [Марию](name)
      # Только фамилия
      - Где найти [Смирнова](name)?
      - Мне нужен [Иванов](name) из [продаж](project:Альфа)
      - Контакты [Кузнецова](name)
      - Кто такой [Петров](name) из [отдела кадров](department)?
      # Имя + Фамилия
      - Найди [Анну Смирнову](name)
      - Ищу [Петра Иванова](name) из [IT](department)
      - Покажи мне [Сергея Кузнецова](name) из отдела [продаж](department)
      - Где работает [Иван Попов](name) в проекте [Омега](project)?
      - Кто такой [Алексей Васильев](name)
      - Контакты [Ольги Петровой](name)
      - Телефон [Виктора Соколова](name)
      - Кабинет [Марии Михайловой](name)
      # Фамилия + Имя
      - Найди [Новикова Константина](name)
      - Ищу [Федорову Елену](name) из [бухгалтерии](department)
      - Покажи мне [Морозова Дмитрия](name)
      - Сотрудник [Волков Михаил](name)
      # Полное ФИО (если применимо)
      - Найди [Смирнова Анну Петровну](name)
      - Мне нужен [Иванов Петр Сергеевич](name)
      - Кто такой [Кузнецов Сергей Иванович](name) из [разработки](department)?
      # С указанием "сотрудник"
      - Сотрудник [Алексеев](name) из [логистики](department)
      - Найди сотрудника [Лебедеву Наталью](name)
      - Мне нужен сотрудник [Семенов Андрей](name)
      # Разные формулировки
      - Подскажи, где [Егорова Ирина](name)?
      - Хочу связаться с [Павлом Фроловым](name)
      - Нужна информация по [Екатерине Беловой](name) из проекта [Гамма](project)
      - Работает ли у нас [Максим Козлов](name)?
      - [Антон Мельников](name) еще в [финансах](department)?
      # С возможными неточностями (Rasa должна научиться их обрабатывать)
      - Ишу [Олексея](name) [Васильева](name) # Опечатка в имени
      - Контакты [Мари Михайловой](name) # Пропущена буква
      # Уменьшительно-ласкательные или сокращения (если не используем синонимы для этого)
      - Где [Женя](name) из [маркетинга](department)? # Если Женя = Евгений
      - Позови [Сашу](name) # Если Саша = Александр/Александра
      # Запросы на поиск, где имя может быть в середине
      - Из [отдела разработки](department) мне нужен [Дмитрий](name)
      - В проекте [Феникс](project) работает [Светлана Зайцева](name), найди ее
      - Это [Михаил Петрович Сидоров](name), верно?
      - По [финансовому отделу](department) ищу [Наталью](name) [Лебедеву](name)

  # Примеры для синонимов (если EntitySynonymMapper активен)
  # Это говорит DIET, что "Женя" - это имя, а EntitySynonymMapper заменит "Женя" на "Евгений"
  - synonym: Евгений
    examples: |
      - Женя
      - Женька
  - synonym: Александр # или Александра, если у вас есть оба
    examples: |
      - Саша
      - Шурик
  - synonym: Василий
    examples: |
      - Вася

  - intent: search_event
    examples: |
      - Какие мероприятия [завтра](date)?
      - Что у нас по [корпоративам](event_name)?
      - Когда будет [летний тимбилдинг](event_name)?
      - Покажи календарь мероприятий на [следующей неделе](date)
      - Будет ли [новогодний праздник](event_name) [в декабре](date)?
      - Расписание [тренингов](event_name)
      - Какие [события](event_name) запланированы на [25 мая](date)

  - intent: find_birthday
    examples: |
      - У кого день рождения [в этом месяце](date)?
      - Когда ДР у [Ивана Петрова](name)?
      - Дни рождения [в июне](date)
      - Покажи список именинников на [сегодня](date)
      - У [Анны](name) скоро день рождения?

  - intent: check_task
    examples: |
      - Какие у меня задачи по проекту [Гамма](project)?
      - Что с задачей [подготовить отчет](task_name)?
      - Проверь статус задачи [релиз новой версии](task_name) на [эту пятницу](date)
      - Мои задачи на [сегодня](date)
      - Какие задачи у [Сергея](name) по проекту [Феникс](project)?

  - intent: check_employment_calendar
    examples: |
      - Проверь занятость [Александра](name) на [завтра](date)
      - Свободен ли [Михаил](name) [10 июня в 3 часа дня](date)?
      - Календарь [Ольги](name)
      - Занятость переговорки [Альфа](room_name) на [вторник](date)

================================================================================

# Файл: data/nlu.yml~
# Содержимое:
version: "3.1"

nlu:
  - intent: greet
    examples: |
      - привет
      - здравствуй
      - добрый день
      - хай
      - здорово

  - intent: goodbye
    examples: |
      - пока
      - до свидания
      - всего доброго
      - бай

  # ... (affirm, deny, bot_challenge как в предыдущем ответе) ...
  - intent: affirm
    examples: |
      - да
      - конечно
      - ага
      - угу
      - согласен

  - intent: deny
    examples: |
      - нет
      - неа
      - не думаю
      - вряд ли

  - intent: bot_challenge
    examples: |
      - ты бот?
      - ты человек?
      - с кем я говорю?

  - intent: search_person
    examples: |
      # Только имя
      - Найди [Анну](name)
      - Где работает [Петр](name)?
      - Мне нужен [Сергей](name) из [IT](department)
      - Кто такая [Ольга](name) из [маркетинга](department)
      - Покажи [Виктора](name)
      - Ищу [Марию](name)
      # Только фамилия
      - Где найти [Смирнова](name)?
      - Мне нужен [Иванов](name) из [продаж](project:Альфа)
      - Контакты [Кузнецова](name)
      - Кто такой [Петров](name) из [отдела кадров](department)?
      # Имя + Фамилия
      - Найди [Анну Смирнову](name)
      - Ищу [Петра Иванова](name) из [IT](department)
      - Покажи мне [Сергея Кузнецова](name) из отдела [продаж](department)
      - Где работает [Иван Попов](name) в проекте [Омега](project)?
      - Кто такой [Алексей Васильев](name)
      - Контакты [Ольги Петровой](name)
      - Телефон [Виктора Соколова](name)
      - Кабинет [Марии Михайловой](name)
      # Фамилия + Имя
      - Найди [Новикова Константина](name)
      - Ищу [Федорову Елену](name) из [бухгалтерии](department)
      - Покажи мне [Морозова Дмитрия](name)
      - Сотрудник [Волков Михаил](name)
      # Полное ФИО (если применимо)
      - Найди [Смирнова Анну Петровну](name)
      - Мне нужен [Иванов Петр Сергеевич](name)
      - Кто такой [Кузнецов Сергей Иванович](name) из [разработки](department)?
      # С указанием "сотрудник"
      - Сотрудник [Алексеев](name) из [логистики](department)
      - Найди сотрудника [Лебедеву Наталью](name)
      - Мне нужен сотрудник [Семенов Андрей](name)
      # Разные формулировки
      - Подскажи, где [Егорова Ирина](name)?
      - Хочу связаться с [Павлом Фроловым](name)
      - Нужна информация по [Екатерине Беловой](name) из проекта [Гамма](project)
      - Работает ли у нас [Максим Козлов](name)?
      - [Антон Мельников](name) еще в [финансах](department)?
      # С возможными неточностями (Rasa должна научиться их обрабатывать)
      - Ишу [Олексея](name) [Васильева](name) # Опечатка в имени
      - Контакты [Мари Михайловой](name) # Пропущена буква
      # Уменьшительно-ласкательные или сокращения (если не используем синонимы для этого)
      - Где [Женя](name) из [маркетинга](department)? # Если Женя = Евгений
      - Позови [Сашу](name) # Если Саша = Александр/Александра
      # Запросы на поиск, где имя может быть в середине
      - Из [отдела разработки](department) мне нужен [Дмитрий](name)
      - В проекте [Феникс](project) работает [Светлана Зайцева](name), найди ее
      - Это [Михаил Петрович Сидоров](name), верно?
      - По [финансовому отделу](department) ищу [Наталью](name) [Лебедеву](name)

  # Примеры для синонимов (если EntitySynonymMapper активен)
  # Это говорит DIET, что "Женя" - это имя, а EntitySynonymMapper заменит "Женя" на "Евгений"
  - synonym: Евгений
    examples: |
      - Женя
      - Женька
  - synonym: Александр # или Александра, если у вас есть оба
    examples: |
      - Саша
      - Шурик
  - synonym: Василий
    examples: |
      - Вася

  - intent: search_event
    examples: |
      - Какие мероприятия [завтра](date)?
      - Что у нас по [корпоративам](event_name)?
      - Когда будет [летний тимбилдинг](event_name)?
      - Покажи календарь мероприятий на [следующей неделе](date)
      - Будет ли [новогодний праздник](event_name) [в декабре](date)?
      - Расписание [тренингов](event_name)
      - Какие [события](event_name) запланированы на [25 мая](date)

  - intent: find_birthday
    examples: |
      - У кого день рождения [в этом месяце](date)?
      - Когда ДР у [Ивана Петрова](name)?
      - Дни рождения [в июне](date)
      - Покажи список именинников на [сегодня](date)
      - У [Анны](name) скоро день рождения?

  - intent: check_task
    examples: |
      - Какие у меня задачи по проекту [Гамма](project)?
      - Что с задачей [подготовить отчет](task_name)?
      - Проверь статус задачи [релиз новой версии](task_name) на [эту пятницу](date)
      - Мои задачи на [сегодня](date)
      - Какие задачи у [Сергея](name) по проекту [Феникс](project)?

  - intent: check_calendar_занятости
    examples: |
      - Проверь занятость [Александра](name) на [завтра](date)
      - Свободен ли [Михаил](name) [10 июня в 3 часа дня](date)?
      - Календарь [Ольги](name)
      - Занятость переговорки [Альфа](room_name) на [вторник](date)

================================================================================

# Файл: data/rules.yml
# Содержимое:
version: "3.1"

rules:
- rule: Say goodbye anytime the user says goodbye
  steps:
  - intent: goodbye
  - action: utter_goodbye

- rule: Say 'I am a bot' anytime the user challenges
  steps:
  - intent: bot_challenge
  - action: utter_iamabot

- rule: Greet user
  steps:
  - intent: greet
  - action: utter_greet

- rule: Process person search request
  steps:
  - intent: search_person
  - action: action_process_request

- rule: Process event search request
  steps:
  - intent: search_event
  - action: action_process_request

- rule: Process birthday find request
  steps:
  - intent: find_birthday
  - action: action_process_request

- rule: Process task check request
  steps:
  - intent: check_task
  - action: action_process_request

- rule: Process calendar check request # <<< ИЗМЕНЕНО НАЗВАНИЕ ИНТЕНТА
  steps:
  - intent: check_employment_calendar # <<< ИЗМЕНЕНО НАЗВАНИЕ ИНТЕНТА
  - action: action_process_request

================================================================================

# Файл: data/stories.yml
# Содержимое:
version: "3.1"

stories:
- story: поиск человека после приветствия
  steps:
  - intent: greet
  - action: utter_greet
  - intent: search_person
    entities: # Примеры сущностей для тестирования
    - name: "Анна"
    - department: "маркетинг"
  - action: action_process_request # Заменяем на наше новое действие

- story: поиск человека без приветствия
  steps:
    - intent: search_person
      entities:
      - name: "Петр"
    - action: action_process_request

- story: поиск мероприятия
  steps:
    - intent: greet
    - action: utter_greet
    - intent: search_event
      entities:
      - event_name: "корпоратив"
      - date: "завтра"
    - action: action_process_request

# Можно добавить больше историй для других интентов и сценариев

================================================================================

# Файл: data/lookups/names.txt
# Содержимое:
# Имена
Анна
Петр
Сергей
Иван
Алексей
Ольга
Виктор
Мария
Константин
Елена
Дмитрий
Светлана
Михаил
Наталья
Андрей
Ирина

# Фамилии
Смирнов
Иванов
Кузнецов
Попов
Васильев
Петров
Соколов
Михайлов
Новиков
Федоров
Морозов
Волков
Алексеев
Лебедев
Семенов
Егоров

Анна Смирнова
Петр Иванов
Сергей Кузнецов
Иван Попов
Алексей Васильев
Ольга Петрова
Виктор Соколов
Мария Михайлова
Константин Новиков
Елена Федорова
Дмитрий Морозов
Светлана Волкова
Михаил Алексеев
Наталья Лебедева
Андрей Семенов
Ирина Егорова


================================================================================

# Файл: data/lookups/names.txt~
# Содержимое:
# Имена
Анна
Петр
Сергей
Иван
Алексей
Ольга
Виктор
Мария
Константин
Елена
Дмитрий
Светлана
Михаил
Наталья
Андрей
Ирина

# Фамилии
Смирнов
Иванов
Кузнецов
Попов
Васильев
Петров
Соколов
Михайлов
Новиков
Федоров
Морозов
Волков
Алексеев
Лебедев
Семенов
Егоров

Анна Смирнова
Петр Иванов
Сергей Кузнецов
Иван Попов
Алексей Васильев
Ольга Петрова
Виктор Соколов
Мария Михайлова
Константин Новиков
Елена Федорова
Дмитрий Морозов
Светлана Волкова
Михаил Алексеев
Наталья Лебедева
Андрей Семенов
Ирина Егорова

================================================================================

# Файл: tests/test_stories.yml
# Содержимое:
stories:
- story: happy path - greet and search person
  steps:
  - user: |
      привет
    intent: greet
  - action: utter_greet
  - user: |
      Найди Виктора из отдела разработки
    intent: search_person
  - action: action_process_request # Убедитесь, что это ваше актуальное действие
  # Можно добавить ассерты на извлеченные слоты, если они заполняются
  # - slot_was_set:
  #   - name: "Виктор"
  #   - department: "разработки"

- story: search person directly
  steps:
  - user: |
      Контакты Ивана Сидорова
    intent: search_person
  - action: action_process_request

- story: search event
  steps:
  - user: |
      Какие мероприятия завтра?
    intent: search_event
  - action: action_process_request

# ... и так далее для других интентов

================================================================================

# Файл: tests/test_stories.yml~
# Содержимое:
#### This file contains tests to evaluate that your bot behaves as expected.
#### If you want to learn more, please see the docs: https://rasa.com/docs/rasa/testing-your-assistant

stories:
- story: happy path 1
  steps:
  - user: |
      hello there!
    intent: greet
  - action: utter_greet
  - user: |
      amazing
    intent: mood_great
  - action: utter_happy

- story: happy path 2
  steps:
  - user: |
      hello there!
    intent: greet
  - action: utter_greet
  - user: |
      amazing
    intent: mood_great
  - action: utter_happy
  - user: |
      bye-bye!
    intent: goodbye
  - action: utter_goodbye

- story: sad path 1
  steps:
  - user: |
      hello
    intent: greet
  - action: utter_greet
  - user: |
      not good
    intent: mood_unhappy
  - action: utter_cheer_up
  - action: utter_did_that_help
  - user: |
      yes
    intent: affirm
  - action: utter_happy

- story: sad path 2
  steps:
  - user: |
      hello
    intent: greet
  - action: utter_greet
  - user: |
      not good
    intent: mood_unhappy
  - action: utter_cheer_up
  - action: utter_did_that_help
  - user: |
      not really
    intent: deny
  - action: utter_goodbye

- story: sad path 3
  steps:
  - user: |
      hi
    intent: greet
  - action: utter_greet
  - user: |
      very terrible
    intent: mood_unhappy
  - action: utter_cheer_up
  - action: utter_did_that_help
  - user: |
      no
    intent: deny
  - action: utter_goodbye

- story: say goodbye
  steps:
  - user: |
      bye-bye!
    intent: goodbye
  - action: utter_goodbye

- story: bot challenge
  steps:
  - user: |
      are you a bot?
    intent: bot_challenge
  - action: utter_iamabot


================================================================================

