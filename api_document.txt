Документация API: Сервис Распознавания Намерений и Сущностей (NLU)

Обзор
Данный API-сервис предназначен для анализа текста на естественном языке (русском) с целью определения намерения (intent) пользователя и извлечения из текста ключевых сущностей (entities). Это позволяет преобразовывать свободные текстовые запросы в структурированные данные, которые могут быть использованы для дальнейшей обработки, например, для формирования запросов к базе данных или выполнения определенных действий.
Сервис построен на базе Rasa NLU.

Базовый URL
Для локальной разработки (когда Rasa сервер запущен на вашей машине):
http://localhost:5005

При развертывании на сервере, замените localhost:5005 на актуальный адрес и порт вашего Rasa сервера.

Эндпоинт
Анализ текста (NLU Parse)
URL: /model/parse
Метод: POST
Описание: Принимает текстовую строку и возвращает JSON-объект с результатами NLU-анализа, включая наиболее вероятное намерение и список извлеченных сущностей.

Headers:
    Content-Type: application/json

Тело запроса (Request Body):
JSON-объект с одним обязательным ключом text.
{
  "text": "Текстовый запрос пользователя"
}
    text (string, required): Текстовая строка, которую необходимо проанализировать.

Ответ (Response):
При успехе (Код 200 OK):
JSON-объект следующей структуры:
{
  "text": "Оригинальный текст запроса пользователя",
  "intent": {
    "id": -7369890801234567890, // Пример ID, может меняться
    "name": "имя_наиболее_вероятного_интента",
    "confidence": 0.9985123872756958
  },
  "entities": [
    {
      "entity": "тип_сущности_1",
      "start": 6,
      "end": 20,
      "confidence_entity": 0.9701234567890123,
      "value": "извлеченное_значение_сущности_1",
      "extractor": "DIETClassifier",
      "processors": ["EntitySynonymMapper"] // Если применялся синонимайзер
    },
    {
      "entity": "тип_сущности_2",
      "start": 30,
      "end": 40,
      "confidence_entity": 0.9212345678901234,
      "value": "извлеченное_значение_сущности_2",
      "extractor": "DIETClassifier",
      "role": "имя_роли" // Если для сущности была определена роль
    }
    // ... другие извлеченные сущности
  ],
  "intent_ranking": [
    {
      "id": -7369890801234567890,
      "name": "имя_наиболее_вероятного_интента",
      "confidence": 0.9985123872756958
    },
    {
      "id": 1234567890123456789,
      "name": "имя_второго_по_вероятности_интента",
      "confidence": 0.0012345678901234567
    }
    // ... остальные интенты с их уверенностью
  ],
  "response_selector": { // Информация от ResponseSelector, если он используется
    "all_retrieval_intents": [],
    "default": {
      "response": {
        "id": null,
        "responses": null,
        "response_templates": null,
        "confidence": 0.0,
        "intent_response_key": null,
        "utter_action": "utter_None",
        "template_name": "utter_None"
      },
      "ranking": []
    }
  }
}

Описание полей ответа:
    text (string): Оригинальный текст, отправленный в запросе.
    intent (object): Объект, описывающий наиболее вероятное намерение.
        id (long): Уникальный идентификатор интента.
        name (string): Имя распознанного намерения (например, search_person, greet).
        confidence (float): Уровень уверенности модели в этом намерении (от 0.0 до 1.0).
    entities (array of objects): Массив объектов, где каждый объект представляет извлеченную сущность. Если сущности не найдены, массив будет пустым.
        entity (string): Тип сущности (например, name, department, date, skill).
        start (integer): Начальный индекс (с 0) первого символа значения сущности в исходной строке text.
        end (integer): Конечный индекс (не включая) последнего символа значения сущности в исходной строке text.
        confidence_entity (float): Уровень уверенности модели в извлечении этой сущности.
        value (string): Извлеченное текстовое значение сущности. После применения EntitySynonymMapper здесь будет каноническое значение.
        extractor (string): Имя компонента Rasa, который извлек эту сущность (например, DIETClassifier, RegexFeaturizer, DucklingEntityExtractor).
        processors (array of string, optional): Список обработчиков, которые модифицировали сущность (например, EntitySynonymMapper).
        role (string, optional): Если для сущности была определена и извлечена роль (например, "lead" для сущности "project"), она будет указана здесь.
    intent_ranking (array of objects): Массив всех возможных намерений, отсортированных по убыванию уверенности. Полезно для отладки или реализации более сложной логики.
        id (long): Уникальный идентификатор интента.
        name (string): Имя интента.
        confidence (float): Уровень уверенности.
    response_selector (object): Информация от компонента ResponseSelector (если используется для выбора ответа).

При ошибке: Стандартные HTTP-коды ошибок (например, 4xx, 5xx) с JSON-телом, описывающим ошибку (зависит от конфигурации Rasa).

Текущие поддерживаемые Интенты и Сущности
На данный момент модель обучена распознавать следующие основные интенты и сущности (согласно domain.yml):

*   Интенты (Намерения):
    *   `greet`: Приветствие.
    *   `goodbye`: Прощание.
    *   `affirm`: Утвердительный ответ.
    *   `deny`: Отрицательный ответ.
    *   `bot_challenge`: Проверка, является ли собеседник ботом.
    *   `search_person`: Запрос на поиск сотрудника.
        *   Может включать фильтрацию по имени, отделу, проекту (включая роль "ответственный за проект"), навыкам/технологиям, точному возрасту, возрасту старше/младше, спецификатору дня рождения (включая "скоро", "на этой неделе").
    *   `search_event`: Запрос на поиск, создание или управление мероприятием.
        *   Может включать фильтрацию по названию мероприятия, дате/периоду, категории, месту проведения, отделу-участнику или организатору. Также может содержать указания на действия (создать, добавить участника, напомнить).
    *   `find_birthday`: Запрос на поиск дней рождения (общий, не как атрибут конкретного сотрудника).
    *   `check_task`: Запрос на проверку задач.
    *   `check_employment_calendar`: Запрос на проверку календаря занятости.

*   Сущности (Entities):
    *   `name`: Имя, фамилия или ФИО человека.
    *   `department`: Название отдела (может использоваться для фильтрации сотрудников или мероприятий).
    *   `project`: Название проекта. Может иметь роль `lead`, если пользователь ищет ответственного за проект.
    *   `skill`: Навык или технология (например, "Python", "Java", "дизайн").
    *   `event_name`: Название мероприятия (например, "Общая планёрка", "летний тимбилдинг").
    *   `date`: Дата или период времени (например, "завтра", "в июне", "25 мая", "10 июня в 18:00"). Распознается DIETClassifier, для более точного распознавания дат рекомендуется настроить DucklingHTTPExtractor.
    *   `task_name`: Название задачи.
    *   `age_exact`: Точный возраст (число).
    *   `age_older_than`: Возраст для условия "старше чем" (число).
    *   `age_younger_than`: Возраст для условия "младше чем" (число).
    *   `birthday_specifier`: Описание дня рождения или периода (например, "в июне", "завтра", "скоро", "на этой неделе"). Может пересекаться с `date`.
    *   `location`: Место проведения мероприятия (например, "переговорка Альфа", "онлайн", "в главном зале").
    *   `event_category`: Категория или тип мероприятия (например, "тренинг", "корпоратив", "онлайн-эвент", "благотворительность").
    *   `organizer`: Организатор мероприятия (например, "HR отдел", "Иван Петров").
    *   `room_name`: Название переговорной комнаты или ресурса (используется в `check_employment_calendar`).


Примеры Запросов и Ответов

Пример 1: Поиск сотрудника
Запрос:
curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{
    "text": "Найди Иванова Петра из отдела разработки"
  }'
Ожидаемый ответ (структура):
{
  "text": "Найди Иванова Петра из отдела разработки",
  "intent": { "name": "search_person", "confidence": 0.99... },
  "entities": [
    { "entity": "name", "value": "Иванова Петра", ... },
    { "entity": "department", "value": "разработки", ... }
  ], ...
}

Пример 2: Поиск мероприятия (расширенный)
Запрос:
curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{
    "text": "Какие корпоративные тренинги для отдела IT будут на следующей неделе в Москве?"
  }'
Ожидаемый ответ (структура):
{
  "text": "Какие корпоративные тренинги для отдела IT будут на следующей неделе в Москве?",
  "intent": { "name": "search_event", "confidence": 0.97... },
  "entities": [
    { "entity": "event_category", "value": "корпоративные тренинги", ... },
    { "entity": "department", "value": "отдела IT", ... },
    { "entity": "date", "value": "на следующей неделе", ... },
    { "entity": "location", "value": "Москве", ... }
  ], ...
}

Пример 3: Простой запрос без сущностей
Запрос:
curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{ "text": "Привет" }'
Ожидаемый ответ (структура):
{
  "text": "Привет",
  "intent": { "name": "greet", "confidence": 0.99... },
  "entities": [], ...
}

Пример 4: Запрос с синонимом
Запрос:
curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{ "text": "Где Женя из маркетинга?" }'
Ожидаемый ответ (структура):
{
  "text": "Где Женя из маркетинга?",
  "intent": { "name": "search_person", "confidence": 0.98... },
  "entities": [
    { "entity": "name", "value": "Евгений", ... }, // EntitySynonymMapper заменил "Женя" на "Евгений"
    { "entity": "department", "value": "маркетинга", ... }
  ], ...
}

Пример 5: Поиск сотрудника с указанием возраста
Запрос:
curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{ "text": "Найди Марию из IT которой 30 лет" }'
Ожидаемый ответ (структура):
{
  "text": "Найди Марию из IT которой 30 лет",
  "intent": { "name": "search_person", "confidence": 0.99... },
  "entities": [
    { "entity": "name", "value": "Марию", ... },
    { "entity": "department", "value": "IT", ... },
    { "entity": "age_exact", "value": "30", ... }
  ], ...
}

Пример 6: Создание мероприятия (интерпретируется бэкендом на основе текста и search_event)
Запрос:
curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{ "text": "Создай внутренний ивент Урок йоги на 10 июня в 18:00 в спортзале" }'
Ожидаемый ответ (структура):
{
  "text": "Создай внутренний ивент Урок йоги на 10 июня в 18:00 в спортзале",
  "intent": { "name": "search_event", "confidence": 0.95... }, // Интент может быть общим
  "entities": [
    { "entity": "event_name", "value": "Урок йоги", ... },
    { "entity": "date", "value": "10 июня в 18:00", ... },
    { "entity": "location", "value": "спортзале", ... }
    // Бэкенд анализирует "Создай" в "text" для выполнения действия
  ], ...
}

Пример 7: Поиск ответственного за проект
Запрос:
curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{ "text": "Кто отвечает за проект SpringSale в маркетинге?" }'
Ожидаемый ответ (структура):
{
  "text": "Кто отвечает за проект SpringSale в маркетинге?",
  "intent": { "name": "search_person", "confidence": 0.99... },
  "entities": [
    { "entity": "project", "value": "SpringSale", "role": "lead", ... },
    { "entity": "department", "value": "маркетинге", ... }
  ], ...
}

Пример 8: Поиск по навыку
Запрос:
curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{ "text": "Найди программистов на Python" }'
Ожидаемый ответ (структура):
{
  "text": "Найди программистов на Python",
  "intent": { "name": "search_person", "confidence": 0.98... },
  "entities": [
    { "entity": "skill", "value": "Python", ... }
  ], ...
}

Пример 9: Добавление участника на мероприятие (интерпретируется бэкендом)
Запрос:
curl -X POST \
  http://localhost:5005/model/parse \
  -H 'Content-Type: application/json' \
  -d '{ "text": "Добавь меня на встречу Обсуждение бюджета 15-го числа" }'
Ожидаемый ответ (структура):
{
  "text": "Добавь меня на встречу Обсуждение бюджета 15-го числа",
  "intent": { "name": "search_event", "confidence": 0.96... },
  "entities": [
    { "entity": "event_name", "value": "Обсуждение бюджета", ... },
    { "entity": "date", "value": "15-го числа", ... }
    // Бэкенд анализирует "Добавь меня" в "text"
  ], ...
}

Запуск сервиса
Для работы API необходимо, чтобы сервер Rasa был запущен с включенным HTTP API. Команда для запуска (выполняется в корневой директории проекта Rasa):
rasa run --enable-api --cors "*" -p 5005
    --enable-api: Включает HTTP API.
    --cors "*": Разрешает Cross-Origin Resource Sharing для всех источников (для разработки). В продакшене рекомендуется настроить более строгие правила CORS.
    -p 5005: Указывает порт (можно изменить при необходимости).